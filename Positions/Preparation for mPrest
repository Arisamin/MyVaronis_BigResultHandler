# Preparation for mPrest Software Developer Interview

## 1. Interview Structure
- Screening: Initial HR or recruiter call to discuss your background and motivation.
- Technical Interview(s): Usually 1–2 rounds, focused on coding, algorithms, and system design.
- Practical Task: You may be given a take-home assignment or live coding exercise (often in C#, Java, or Python).
- Team/Manager Interview: Discussion about your experience, teamwork, and fit for their agile environment.
- Final Interview: Sometimes with senior management or CTO, especially for senior roles.

## 2. Technical Focus

### C#/.NET Fundamentals & OOP
- What are value types vs. reference types in C#? (OOP, memory)
- How does garbage collection work in .NET? (Memory management)
- What is the difference between `interface` and `abstract class`? (OOP)
- How does inheritance work in C#? What is method overriding vs. method hiding? (OOP)
- What is the difference between `==` and `.Equals()`? (Equality, OOP)
- How do you override `GetHashCode` and `Equals`? (Equality, OOP)
- What are extension methods? (OOP, language features)
- What are attributes and how do you use reflection? (Language features)

### Delegates, Events, and LINQ
- What are delegates and events? How do you use them? (Delegates/events)
- What is LINQ and how is it used? (LINQ, collections)

### Generics & Collections
- How do you implement and use generics? (Generics)
- What is the difference between `IEnumerable`, `ICollection`, and `IList`? (Collections)
- How do you serialize and deserialize objects in C#? (Serialization)
## 3. Domain-Specific Areas
### Exception Handling & Asynchronous Programming
- How does exception handling work in C#? (Exceptions)
- What are async/await and how does asynchronous programming work in .NET? (Async)
- Real-Time Systems: Questions about latency, throughput, and reliability.
### Multithreading & Dependency Injection
- How do you implement thread safety and use locking mechanisms? (Multithreading)
- What is dependency injection and why is it useful? (Design patterns, architecture)
- Distributed Systems: Message queues, event-driven architecture, microservices.
- IoT/Industrial: Protocols, device management, telemetry, and data pipelines.

## 4. Behavioral & Soft Skills
- Teamwork: Agile methodologies, working in cross-functional teams.
- Problem Solving: How you approach complex, ambiguous problems.
- Communication: Explaining technical concepts clearly.

## 5. Tips
- Review C#/.NET fundamentals, especially for backend roles.
- Practice system design interviews (real-time, distributed, scalable systems).
- Be ready to discuss past projects, especially those involving mission-critical or high-availability systems.
- Prepare for practical coding and debugging exercises.
- Show curiosity about their products (energy, defense, IoT) and ask questions about their tech stack and challenges.

---


---

## Data Structures Reference

### 1. Core Data Structures
- **Arrays:** Fixed-size, fast access by index, slow insert/delete except at end.
- **Lists (LinkedList):** Dynamic size, fast insert/delete at ends, slow random access.
- **Stacks:** LIFO (Last-In-First-Out), push/pop operations, used for recursion, parsing.
- **Queues:** FIFO (First-In-First-Out), enqueue/dequeue, used for scheduling, BFS.
- **Hash Tables (Dictionary/Map):** Key-value storage, fast lookup/insert/delete, handle collisions.
- **Trees (Binary, BST, AVL, Heap):** Hierarchical, used for searching, sorting, priority queues.
- **Graphs:** Nodes and edges, can be directed/undirected, used for network, dependency, and pathfinding problems.

### 2. Operations to Know
- How to insert, delete, search, and traverse each structure.
- Time and space complexity for each operation (Big O notation).
- When to use each structure (trade-offs).

### 3. Implementation Details
- How to implement a linked list, stack, or queue from scratch.
- How to traverse trees (in-order, pre-order, post-order, level-order).
- How to represent graphs (adjacency list vs. matrix).

### 4. Common Interview Problems
- Reverse a linked list.
- Detect a cycle in a linked list or graph.
- Find the kth largest/smallest element.
- Implement a queue using two stacks.
- Use a hash table to count occurrences or find duplicates.

### 5. Advanced Topics (for senior/real-time roles)
- Thread-safe collections (ConcurrentQueue, locks).
- Custom data structures for performance (ring buffer, trie).
- Memory usage and cache efficiency.

### 6. Practical Tips
- Be able to explain your choice of data structure for a given problem.
- Know how to optimize for time vs. space.
- Practice coding basic structures without using built-in libraries.

---

## Questions and Answers

**Q: What is the difference between value types and reference types in C#? Give examples of each.**

A: Value types are types that are created directly on the stack when declared in the code. When they are passed to a method they are passed by value—meaning a copy of them is passed. Examples include integers and structs.

Reference types are types that are created on the stack when declared in the code (the compiler is enforcing their creation through constructors (new keyword)). When they are passed into functions they are passed by reference (pointer to the actual object on the stack), which means that changes that are applied to the object inside the function are effective outside of it as well. Examples include strings or arrays.

[Chat answer]
**Value types** (e.g., `int`, `double`, `struct`) store their data directly, and assignment or parameter passing **copies the value**. They are **usually stored on the stack, but can also be on the heap** (for example, as part of a class or array).

**Reference types** (e.g., `class`, `string`, `array`) store a **reference to the actual data, which is always on the heap**. Assignment or parameter passing **copies the reference (not the object itself)**, so multiple variables can refer to the same object. **Modifying the object through one reference is visible to all references.**

**Key differences:**
- **Value types: assignment and parameter passing copies the value.**
- **Reference types: assignment and parameter passing copies the reference, not the object.**
- **Reference type objects are always on the heap; value types can be on the stack or heap.**

**Q: What is the difference between passing a reference type to a method normally, and passing it with the `ref` keyword? What does `ref` mean for reference types?**

A: Passing a reference type to a method normally allows the method to modify the object's data, and those changes are visible outside the method. However, if the method assigns a new object to the parameter, this change is local to the method—the original reference outside the method remains unchanged.

**Q: How does garbage collection work in .NET? When is an object eligible for collection?**

A: .NET GC uses three generations: Gen 0 (new/short-lived), Gen 1 (medium-lived), Gen 2 (long-lived/large objects). New objects are allocated in Gen 0 (unless large, then Gen 2/LOH). Surviving objects are promoted to higher generations and may be moved in memory (except large objects, which are not compacted). An object is eligible for collection when it is unreachable from any live code (roots). Finalization, if present, adds extra work to the GC cycle. The GC is non-deterministic and collections occur as needed for memory management and performance.

**Q: What is boxing and unboxing in C#? When do they occur, and what are the performance implications?**

A: Boxing is the action of wrapping a value that otherwise would have been allocated on the stack in an object that is allocated on the heap.
Unboxing is the opposite action - taking a value that can be allocated on the stack out of an object that is allocated on the heap.
The performance implications are the overhead of creating and collecting of a heap object that could have been otherwise handled by handling a stack frame.

[Chat GPT comments]
Your answer is clear and mostly accurate. Here are some areas to strengthen it:

- **When they occur:** Clarify that boxing occurs when a value type is converted to an object or any interface it implements (e.g., `object obj = 5;` or passing an `int` to a method expecting `object`). Unboxing is the reverse and requires an explicit cast.
- **Type safety:** Mention that unboxing can throw an `InvalidCastException` if the types do not match exactly (e.g., trying to unbox a boxed `int` as a `long`).
- **Real-world scenarios:** Boxing often happens implicitly with collections (e.g., `ArrayList` before generics), LINQ operations, and method calls with `object` parameters. Modern code using generics reduces boxing overhead.
- **Performance impact:** Your mention of heap allocation and GC overhead is correct, but also note that boxing involves copying the value into the heap object, and unboxing copies it back—both are CPU-intensive operations in tight loops.

**Improved phrasing:**
> Boxing converts a value type to an object, allocating it on the heap and copying the value. Unboxing extracts the value, requiring an explicit cast and throwing an exception if types do not match. The main costs are heap allocation, garbage collection, and the copy operations themselves—significant in performance-critical code.

#### Key Concepts & Interview Issues from Discussion
- Objects are allocated in generations: Gen 0 (new), Gen 1 (survived one collection), Gen 2 (long-lived/large objects).
- Most objects die young; Gen 0 is collected most frequently and quickly.
- Surviving objects are promoted to higher generations and are moved in memory (except large objects).
- Large objects (≥85,000 bytes) are allocated directly in Gen 2 (Large Object Heap) and are not compacted by default.
- Gen 2 collections are less frequent but more expensive; LOH fragmentation can occur.
- Finalization (destructors) adds extra work to GC cycles if present in unreachable objects.
- The GC is non-deterministic: you cannot predict exactly when collection will occur.
- Generational GC optimizes for performance by focusing frequent collections on short-lived objects and less frequent collections on long-lived/large objects.

**Q: What is the difference between an `interface` and an `abstract class` in C#? When would you use each?**

A: An interface is a contract that an implementing class must adhere to by implementing the exact signatures (methods, properties, events) defined in the interface. An abstract class is similar to an interface in that it defines a contract, but it can also include implementation of functionality in addition to abstract members. 

Key differences:
- An interface cannot have implementation; an abstract class can.
- A class can implement multiple interfaces but can inherit from only one abstract class.
- Use an interface to define a contract/behavior that unrelated classes should follow. Use an abstract class to define a base class for related classes that share common functionality.

Additional considerations:
- **C# 8.0+ enhancement:** Interfaces can now have default implementations (concrete methods), which blurs the traditional line between interfaces and abstract classes.
- **Access modifiers:** Abstract classes can have private/protected members; interfaces can only have public members.
- **Constructors:** Abstract classes can have constructors; interfaces cannot.
- **State:** Abstract classes can have fields with state; interfaces cannot (only properties).

**Q: How does inheritance work in C#? What is the difference between method overriding and method hiding?**

A: Inheritance in C# is implemented using a vTable (virtual method table) which maps the overloads of a member to its respective object in the hierarchy. 

**Method Overriding:**
- To override a method, it must first be marked as `virtual` in the base class.
- The derived class uses the `override` keyword to override the virtual method.
- Both the virtual method and its override exist in the vTable, and the correct version is called based on the actual object type at runtime (polymorphism).
- The base class method can be accessed from the derived class using the `base` keyword if needed.

**Method Hiding:**
- Method hiding occurs when a derived class implements a signature that already exists in the base class, but does not want the base class behavior and does not want the base class method to be accessible through polymorphism.
- To hide a method, the derived class uses the `new` keyword on the method signature.
- This breaks the polymorphic chain for that method; calls through a base class reference will use the base version, while calls through a derived class reference will use the hidden version.

**Q: What is the difference between value types and primitive types in C#?**

A: In C#, **primitive types** are a subset of **value types**. 

**Value Types** include:
- **Primitive types:** `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, `decimal`, `bool`, `char`
- **Structs:** User-defined value types created with the `struct` keyword
- **Enums:** Enumeration types
- **Nullable types:** `T?` (e.g., `int?`, `bool?`)

**Primitive types** are built-in value types provided by the language and CLR. They are the fundamental building blocks for other types and have direct language support for literals and operators. They directly map to CLR types (e.g., `int` = `System.Int32`) and are optimized by the runtime.

**Key relationship:** All primitive types are value types, but not all value types are primitive types (e.g., custom structs are value types but not primitive types).