# Preparation for mPrest Software Developer Interview

## 1. Interview Structure
- Screening: Initial HR or recruiter call to discuss your background and motivation.
- Technical Interview(s): Usually 1–2 rounds, focused on coding, algorithms, and system design.
- Practical Task: You may be given a take-home assignment or live coding exercise (often in C#, Java, or Python).
- Team/Manager Interview: Discussion about your experience, teamwork, and fit for their agile environment.
- Final Interview: Sometimes with senior management or CTO, especially for senior roles.

## 2. Technical Focus

### C#/.NET Fundamentals & OOP
- What are value types vs. reference types in C#? (OOP, memory)
- How does garbage collection work in .NET? (Memory management)
- What is the difference between `interface` and `abstract class`? (OOP)
- How does inheritance work in C#? What is method overriding vs. method hiding? (OOP)
- What is the difference between `==` and `.Equals()`? (Equality, OOP)
- How do you override `GetHashCode` and `Equals`? (Equality, OOP)
- What are extension methods? (OOP, language features)
- What are attributes and how do you use reflection? (Language features)

### Delegates, Events, and LINQ
- What are delegates and events? How do you use them? (Delegates/events)
- What is LINQ and how is it used? (LINQ, collections)

### Generics & Collections
- How do you implement and use generics? (Generics)
- What is the difference between `IEnumerable`, `ICollection`, and `IList`? (Collections)
- How do you serialize and deserialize objects in C#? (Serialization)
## 3. Domain-Specific Areas
### Exception Handling & Asynchronous Programming
- How does exception handling work in C#? (Exceptions)
- What are async/await and how does asynchronous programming work in .NET? (Async)
- Real-Time Systems: Questions about latency, throughput, and reliability.
### Multithreading & Dependency Injection
- How do you implement thread safety and use locking mechanisms? (Multithreading)
- What is dependency injection and why is it useful? (Design patterns, architecture)
- Distributed Systems: Message queues, event-driven architecture, microservices.
- IoT/Industrial: Protocols, device management, telemetry, and data pipelines.

## 4. Behavioral & Soft Skills
- Teamwork: Agile methodologies, working in cross-functional teams.
- Problem Solving: How you approach complex, ambiguous problems.
- Communication: Explaining technical concepts clearly.

## 5. Tips
- Review C#/.NET fundamentals, especially for backend roles.
- Practice system design interviews (real-time, distributed, scalable systems).
- Be ready to discuss past projects, especially those involving mission-critical or high-availability systems.
- Prepare for practical coding and debugging exercises.
- Show curiosity about their products (energy, defense, IoT) and ask questions about their tech stack and challenges.

---


---

## Data Structures Reference

### 1. Core Data Structures
- **Arrays:** Fixed-size, fast access by index, slow insert/delete except at end.
- **Lists (LinkedList):** Dynamic size, fast insert/delete at ends, slow random access.
- **Stacks:** LIFO (Last-In-First-Out), push/pop operations, used for recursion, parsing.
- **Queues:** FIFO (First-In-First-Out), enqueue/dequeue, used for scheduling, BFS.
- **Hash Tables (Dictionary/Map):** Key-value storage, fast lookup/insert/delete, handle collisions.
- **Trees (Binary, BST, AVL, Heap):** Hierarchical, used for searching, sorting, priority queues.
- **Graphs:** Nodes and edges, can be directed/undirected, used for network, dependency, and pathfinding problems.

### 2. Operations to Know
- How to insert, delete, search, and traverse each structure.
- Time and space complexity for each operation (Big O notation).
- Reverse a linked list.
**Crucial .NET internals:**
When you use methods like `List<T>.Contains()` or `List<T>.IndexOf()`, the equality comparison is performed by `EqualityComparer<T>.Default`. This comparer automatically checks if your type `T` implements `IEquatable<T>`. If so, it uses your `Equals(T other)` method for comparisons. If not, it falls back to using `object.Equals()`. This means that implementing `IEquatable<T>` directly affects how these collection methods determine equality, and is the recommended way to provide custom equality logic for your types in .NET collections.

**List<T> methods using EqualityComparer<T>.Default:**
Several methods of `List<T>` use `EqualityComparer<T>.Default` to determine equality:
- `Contains(T item)`
- `IndexOf(T item)`
- `LastIndexOf(T item)`
- `Remove(T item)`
- `RemoveAll(Predicate<T> match)` (indirectly, if you use equality in the predicate)
These methods will use your custom equality logic if you implement `IEquatable<T>`, otherwise they use `object.Equals()`.

**What is EqualityComparer<T>.Default?**
`EqualityComparer<T>.Default` is a built-in .NET singleton that provides the default way to compare two objects of type `T` for equality and to get their hash codes. If your type implements `IEquatable<T>`, it uses your `Equals(T other)` method; otherwise, it falls back to `object.Equals()`. This mechanism ensures that collections like `List<T>`, `Dictionary<TKey, TValue>`, and `HashSet<T>` use the most efficient and type-appropriate equality logic available.
- Detect a cycle in a linked list or graph.
- Find the kth largest/smallest element.

### 5. Advanced Topics (for senior/real-time roles)

**Prime numbers in GetHashCode:**
When implementing `GetHashCode()`, it's best practice to combine multiple fields using prime numbers (e.g., multiply by 31 or 397) to reduce hash collisions and distribute hash codes more evenly. For example:
```csharp
public override int GetHashCode()
{
	unchecked
	{
		int hash = 17;
		hash = hash * 31 + field1.GetHashCode();
		hash = hash * 31 + field2.GetHashCode();
		// ...
		return hash;
	}
}
```
Or use `HashCode.Combine()` in .NET Core and later for simplicity and reliability.
### 6. Practical Tips
- Be able to explain your choice of data structure for a given problem.
- Know how to optimize for time vs. space.

A: Value types are types that are created directly on the stack when declared in the code. When they are passed to a method they are passed by value—meaning a copy of them is passed. Examples include integers and structs.

**Value types** (e.g., `int`, `double`, `struct`) store their data directly, and assignment or parameter passing **copies the value**. They are **usually stored on the stack, but can also be on the heap** (for example, as part of a class or array).

- **Reference type objects are always on the heap; value types can be on the stack or heap.**
**Q: What is the difference between passing a reference type to a method normally, and passing it with the `ref` keyword? What does `ref` mean for reference types?**

A: Passing a reference type to a method normally allows the method to modify the object's data, and those changes are visible outside the method. However, if the method assigns a new object to the parameter, this change is local to the method—the original reference outside the method remains unchanged.

**Q: How does garbage collection work in .NET? When is an object eligible for collection?**

A: .NET GC uses three generations: Gen 0 (new/short-lived), Gen 1 (medium-lived), Gen 2 (long-lived/large objects). New objects are allocated in Gen 0 (unless large, then Gen 2/LOH). Surviving objects are promoted to higher generations and may be moved in memory (except large objects, which are not compacted). An object is eligible for collection when it is unreachable from any live code (roots). Finalization, if present, adds extra work to the GC cycle. The GC is non-deterministic and collections occur as needed for memory management and performance.

**Q: What is boxing and unboxing in C#? When do they occur, and what are the performance implications?**

A: Boxing is the action of wrapping a value that otherwise would have been allocated on the stack in an object that is allocated on the heap.
Unboxing is the opposite action - taking a value that can be allocated on the stack out of an object that is allocated on the heap.
The performance implications are the overhead of creating and collecting of a heap object that could have been otherwise handled by handling a stack frame.

[Chat GPT comments]
Your answer is clear and mostly accurate. Here are some areas to strengthen it:

- **When they occur:** Clarify that boxing occurs when a value type is converted to an object or any interface it implements (e.g., `object obj = 5;` or passing an `int` to a method expecting `object`). Unboxing is the reverse and requires an explicit cast.
- **Type safety:** Mention that unboxing can throw an `InvalidCastException` if the types do not match exactly (e.g., trying to unbox a boxed `int` as a `long`).
- **Real-world scenarios:** Boxing often happens implicitly with collections (e.g., `ArrayList` before generics), LINQ operations, and method calls with `object` parameters. Modern code using generics reduces boxing overhead.
- **Performance impact:** Your mention of heap allocation and GC overhead is correct, but also note that boxing involves copying the value into the heap object, and unboxing copies it back—both are CPU-intensive operations in tight loops.

**Improved phrasing:**
> Boxing converts a value type to an object, allocating it on the heap and copying the value. Unboxing extracts the value, requiring an explicit cast and throwing an exception if types do not match. The main costs are heap allocation, garbage collection, and the copy operations themselves—significant in performance-critical code.

#### Key Concepts & Interview Issues from Discussion
- Objects are allocated in generations: Gen 0 (new), Gen 1 (survived one collection), Gen 2 (long-lived/large objects).
- Most objects die young; Gen 0 is collected most frequently and quickly.
- Surviving objects are promoted to higher generations and are moved in memory (except large objects).
- Large objects (≥85,000 bytes) are allocated directly in Gen 2 (Large Object Heap) and are not compacted by default.
- Gen 2 collections are less frequent but more expensive; LOH fragmentation can occur.
- Finalization (destructors) adds extra work to GC cycles if present in unreachable objects.
- The GC is non-deterministic: you cannot predict exactly when collection will occur.
- Generational GC optimizes for performance by focusing frequent collections on short-lived objects and less frequent collections on long-lived/large objects.

**Q: What is the difference between an `interface` and an `abstract class` in C#? When would you use each?**

A: An interface is a contract that an implementing class must adhere to by implementing the exact signatures (methods, properties, events) defined in the interface. An abstract class is similar to an interface in that it defines a contract, but it can also include implementation of functionality in addition to abstract members. 

Key differences:
- An interface cannot have implementation; an abstract class can.
- A class can implement multiple interfaces but can inherit from only one abstract class.
- Use an interface to define a contract/behavior that unrelated classes should follow. Use an abstract class to define a base class for related classes that share common functionality.

Additional considerations:
- **C# 8.0+ enhancement:** Interfaces can now have default implementations (concrete methods), which blurs the traditional line between interfaces and abstract classes.
- **Access modifiers:** Abstract classes can have private/protected members; interfaces can only have public members.
- **Constructors:** Abstract classes can have constructors; interfaces cannot.
- **State:** Abstract classes can have fields with state; interfaces cannot (only properties).

**Q: How does inheritance work in C#? What is the difference between method overriding and method hiding?**

A: Inheritance in C# is implemented using a vTable (virtual method table) which maps the overloads of a member to its respective object in the hierarchy. 

**Method Overriding:**
- To override a method, it must first be marked as `virtual` in the base class.
- The derived class uses the `override` keyword to override the virtual method.
- Both the virtual method and its override exist in the vTable, and the correct version is called based on the actual object type at runtime (polymorphism).
- The base class method can be accessed from the derived class using the `base` keyword if needed.

**Method Hiding:**
- Method hiding occurs when a derived class implements a signature that already exists in the base class, but does not want the base class behavior and does not want the base class method to be accessible through polymorphism.
- To hide a method, the derived class uses the `new` keyword on the method signature.
- This breaks the polymorphic chain for that method; calls through a base class reference will use the base version, while calls through a derived class reference will use the hidden version.

**Q: What is the difference between value types and primitive types in C#?**

A: In C#, **primitive types** are a subset of **value types**. 

**Value Types** include:
- **Primitive types:** `byte`, `sbyte`, `short`, `ushort`, `int`, `uint`, `long`, `ulong`, `float`, `double`, `decimal`, `bool`, `char`
- **Structs:** User-defined value types created with the `struct` keyword
- **Enums:** Enumeration types
- **Nullable types:** `T?` (e.g., `int?`, `bool?`)

**Primitive types** are built-in value types provided by the language and CLR. They are the fundamental building blocks for other types and have direct language support for literals and operators. They directly map to CLR types (e.g., `int` = `System.Int32`) and are optimized by the runtime.

**Key relationship:** All primitive types are value types, but not all value types are primitive types (e.g., custom structs are value types but not primitive types).

**Q: What is the difference between `==` and `.Equals()` in C#? When should you use each?**

A: `==` by default is a value equality operator, while `Equals()` usually does deep comparison of objects—comparing them by the equality of their members.

For value types (except for structs), using `==` is equivalent to comparing them by `Equals()`, because comparing their values is what `Equals` will do for them.

For reference types, comparing with `==` will compare their references (pointers). While two different objects can have different pointers, semantically they may be equal because their internal data is the same. In this case, `==` is not the correct way to semantically compare them.

[Chat GPT comments]
Your answer is excellent and demonstrates a solid understanding of the distinction. Here are some areas to expand on for a more comprehensive interview answer:

- **Operator overloading:** Mention that both `==` and `Equals()` can be overloaded. By default, `==` for reference types compares references, but classes can override this to compare semantically (e.g., `string` overloads `==` to compare content, not references).
- **String special case:** Strings are reference types, but `==` and `Equals()` both compare their content, not references, because string overloads `==`. This is a common gotcha.
- **Null safety:** Note that `==` handles null gracefully, while `Equals()` can throw a `NullReferenceException` if called on a null reference (though it's safer to use `?.Equals()` or check for null first).
- **Performance:** `Equals()` is a virtual method call, while `==` is typically faster (but can be overloaded, so this isn't always true). For performance-critical code, `==` is usually preferred.
- **Best practice:** Override both `==` and `Equals()` consistently if implementing a custom type; they should produce the same results. Also override `GetHashCode()` when overriding `Equals()` to maintain consistency with hash-based collections.
- **IEquatable<T>:** For value types and when performance matters, implementing `IEquatable<T>` and overriding `Equals()` avoids boxing and is more efficient than relying on the default implementation.

**How List<T> uses IEquatable<T> and EqualityComparer<T>.Default:**
Many methods of `List<T>`—such as `Contains(T item)`, `IndexOf(T item)`, `LastIndexOf(T item)`, and `Remove(T item)`—use `EqualityComparer<T>.Default` to determine equality. This comparer checks if your type implements `IEquatable<T>`, and if so, uses your `Equals(T other)` method. Otherwise, it falls back to `object.Equals()`. This is why implementing `IEquatable<T>` is crucial for custom value or reference types: it ensures your equality logic is used by .NET collections and their search/removal methods.

**What is EqualityComparer<T>.Default?**
`EqualityComparer<T>.Default` is a built-in singleton that provides the default way to compare two objects of type `T` for equality and to get their hash codes. It automatically uses your `IEquatable<T>.Equals` implementation if present, otherwise it uses `object.Equals()`. This mechanism is used by collections like `List<T>`, `Dictionary<TKey, TValue>`, and `HashSet<T>` to ensure efficient and type-appropriate equality checks.

**Q: How do you override `GetHashCode()` and `Equals()` in C#? Why is it important to override both together?**

A: **Overriding `GetHashCode()`:** Should try to distribute the values it returns equally to create effective bucketing of instances. The key rule is that if two different instances are equal according to `Equals()`, they **must** have the same hash code. This ensures that if two instances have different hash codes, they are certainly not equal.

**Overriding `Equals()`:** Should ensure that if two instances have exactly the same data (recursively), they must be considered equal by this method. This also ensures that an instance compared to itself always returns true.

**Why override both together:** These two methods are intrinsically linked. If you override `Equals()` to define a new equality contract, you must override `GetHashCode()` accordingly to maintain the contract that equal objects have equal hash codes. Failing to do so breaks hash-based collections like `Dictionary`, `HashSet`, and `Hashtable`, where objects are located by hash code first and then compared with `Equals()`. This contract violation can lead to objects being "lost" or incorrectly retrieved from these collections.

[Chat GPT comments]
Your answer is excellent and demonstrates a strong understanding of the intrinsic relationship between these two methods. Here are some areas to expand for a more comprehensive answer:

- **Hash code contract clarity:** Emphasize the asymmetry: equal objects MUST have equal hash codes, but different objects CAN have the same hash code (hash collision). This is why hash code alone is insufficient for equality.
- **`GetHashCode()` implementation tips:** Mention that a good hash code combines multiple fields using prime numbers or `HashCode.Combine()` (in .NET Core), and should ideally use immutable data. Also note that `GetHashCode()` should not throw exceptions and should be consistent (same object should always return same hash code).
- **`Equals()` implementation tips:** Should compare all relevant fields, handle null references gracefully, check type compatibility first (is the other object the same type?), and delegate to `Equals()` on member objects recursively.
- **Practical warning:** Violating the hash code contract is a subtle bug because it often works initially but breaks intermittently when hash tables grow or rehash internally, making it hard to debug.
- **Example scenarios:** Hash collision handling (multiple objects with same hash code but different equality), what happens when you add an object to a `Dictionary` with one hash code, then change its internal data and try to retrieve it.
- **IEquatable<T> integration:** When implementing `Equals()`, also implement `IEquatable<T>` for better performance, and override the `==` and `!=` operators to remain consistent.